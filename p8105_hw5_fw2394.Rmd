---
title: "p8105_hw5_fw2394"
author: "Fang Wang"
date: "2024-11-14"
output: github_document
---

# Load library and set up:
```{r, include = FALSE, message = FALSE, warning = FALSE}
library(tidyverse)
library(purrr)
library(broom)

knitr::opts_chunk$set(
  fig.width = 6,
  fig.asp =.6,
  out.width = "90%"
)

theme_set (theme_bw() + theme (
    legend.position =  "bottom"
  ))

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)
scale_color_discrete = scale_color_viridis_d()
scale_fill_discrete = scale_fill_viridis_d()
```


# Problem 1

## Draw "birthdays" to check duplicates:
```{r}
bday_sim = function (n) {
  bdays = sample (1:365, size = n, replace = TRUE)
  
  duplicate = length(unique(bdays)) < n
  
  return (duplicate)
}

set.seed(0415)
bday_sim (200)
```

*The "TRUE" means that there is at least one pair of people in a group of 200 share the same birthday.*

## Run 10000 times for each group size between 2 and 50:
```{r}
sim_result =
  expand_grid (
    n = 2:50,
    iter =1:10000
  ) |> 
  mutate (result = map_lgl(n, bday_sim)) |> 
  group_by(n) |> 
  summarise (prob_duplicate = mean(result))
```

*In the dataset, "n" represents the size of a group. "prob_duplicate" represents the estimated probability of having at least one pair of people with the same birthday for different group sizes n.*

## Make a plot between group size and probability of shared birthday:
```{r}
sim_result |> 
  ggplot(aes (x = n, y = prob_duplicate)) +
  geom_line() +
  labs(
    title = "Probability of Shared Birthday in a Group",
    x = "Group Size (n)",
    y = "Probability of Shared Birthday"
  ) +
  theme(plot.title=element_text(size=15, face="bold"))+
  theme(plot.title = element_text(hjust = 0.5))
```
*The plot illustrates the birthday paradox: as group size grows, the probability of a shared birthday rises sharply. Despite 365 possible birthdays, a relatively small group is enough to make a shared birthday likely.*

# Problem 2

## write a function to create datasets:
```{r}
# set parameters
set.seed(2)
n = 30
sigma = 5
alpha = 0.05
mus = 0:6
num_simulations = 5000

generate_data = function(mu, sigma, n) {
  rnorm(n, mean = mu, sd = sigma)
}
```

## write a function to perform t.test:
```{r}
perform_t_test = function(data) {
  test = t.test(data, mu = 0)
  tidy_test = tidy(test)
  
  tidy_test |> 
    select(estimate, p.value) |> 
    rename(mu_hat = estimate,
           p_value = p.value)
}
```

## write a function for simulation:
```{r}

simulate_for_mu = function(mu, num_simulations, n, sigma) {
  
  results = map_dfr(1:num_simulations, function(i) {
     data = generate_data(mu, sigma, n)
    
    test_results = perform_t_test(data)
    
  
    test_results |> 
      mutate(mu_true = mu)
  })
  
  return(results)
}
```

## perform simulation for all datasets:
```{r}


run_simulation = function(mus, num_simulations, n, sigma) {
  
  map_dfr(mus, function(mu) {
    simulate_for_mu(mu, num_simulations, n, sigma)
  })
}

results = run_simulation(mus, num_simulations, n, sigma)

head (results)
```

## Calculate power and mean estimates
```{r}
summary_results = results |> 
  group_by(mu_true) |> 
  summarize(
    power = mean(p_value < alpha), 
    avg_mu_hat = mean(mu_hat),
    avg_mu_hat_rejected = mean(mu_hat[p_value < alpha])
  )
```

## plot mu_true and power
```{r}
ggplot(summary_results, aes(x = mu_true, y = power)) +
  geom_line() +
  geom_point() +
  labs(x = "True Value of μ", y = "Power", 
       title = "Power of the One-Sample T-Test vs. Effect Size (μ)")+
  theme(plot.title=element_text(size=11, face="bold")) +
  theme(plot.title = element_text(hjust = 0.5))
```
*The plot illustrates that there is a positive association between effect size and power. As the effect size increases, the test becomes more powerful, approaching perfect power (1.0) at higher values of mu. This means that detecting a true effect is more likely with a larger effect size, while smaller effect sizes result in lower power and thus a higher chance of failing to reject the null hypothesis when it is false.*

## plot mu_hat vs. true mu between all samples and only rejrected samples:
```{r}
ggplot(summary_results, aes(x = mu_true)) +
geom_line(aes(y = avg_mu_hat, color = "All samples", linetype = "All samples"), size = 1) +
geom_line(aes(y = avg_mu_hat_rejected, color = "Only rejected", linetype = "Only rejected"), size = 1) +
  labs(x = "True Value of μ", 
       y = "Average Estimate of μ̂", 
   title = "Average Estimate of μ̂ vs. True μ") +
scale_color_manual(name = "Estimate Type", values = c("All samples" = "blue", "Only rejected" = "red")) +
scale_linetype_manual(name = "Estimate Type", values = c("All samples" = "solid", "Only rejected" = "dashed"))+
theme(plot.title=element_text(size=16, face="bold")) +
theme(plot.title = element_text(hjust = 0.5)) +
theme(legend.position = c(0.8, 0.15),
      legend.background = element_blank()) 
```
*For smaller values of μ, the average estimate of μ in only the rejected samples does not equal the true μ but is biased upward. This is due to selection bias, where only samples with higher estimates are likely to reject the null hypothesis. For larger values of μ, this bias diminishes, and the average estimate aligns more closely with the true value.*